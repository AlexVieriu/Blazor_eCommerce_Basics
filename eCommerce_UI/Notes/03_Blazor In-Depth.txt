23. Data Binding Part 1

-- Index.razor --

UI:

-> one way data binding : State-> View
	Product Name: @product.Name

-> two ways data binding: State-> View, View->State
	<input type="text" @bind-value="@product.Name" @bind-value:event="oninput" />

CheckBox:
<input type="checkbox" @bind-value="isActive">
@isActive


@Code:

private bool isActive;
Product product = new Product(){....};


25. Overview of Communication between Components

-> page components
-> non-page components(reusable components)
	-> can have multiple non-page components

a. Rounting Parameters
b. Regular Parameters
c. Cascading Parameters
d. EventCallback
e. Reference 


26. Review Parameters, Route Parameters and EventCallback

I. Regular Parameters
-> ex: in a foreach function we pass the parameter from the base component to the child component

II. Rounting Parameters
-> pass parameter from one component to another: base comp	-> base component
												 child comp	-> base component
ex: @page "/product/{id:int}"

III. EventCallback

-> we create a parameter:	filter at the child component level and we pass it to the base component using 
							EventCallback parameter


27. Cascading Parameters

-> we only can cascade values from the top to the bottom, from base component to the child component

-> create a Base Component, with a button that pass the parameter to all his childs
-> create Component1.razor, Component2.razor

-> StateHasChanged(): 



28. Referencing Child Components

-> base component can access the methods from the child component and use it 

UI:
-> declare <Visibility> with the @ref so we can display it
-> create a button that access the visibilityComponent method

@code:
-> write the @onclick event that access the method from the child component


29. RenderFragment

-- RenderFrag --

UI: 
<TemplatedComponent Items="products" TItems="Product">
	<Header>
	<ReapeaterItem Context="item">
       <p>Name: @item.Name</p>
       <p>Brand: @item.Brand</p>
       <p>Description: @item.Description</p>      
	<Footer>

@Code:
{
	create a List of Products
}


-- TemplaterComponent.razor --

UI: 

@Header
foreach(...)
@Footer


@code:

RenderFragment Header 
RenderFragment Footer
List<TItems> Items 
RenderFragment<TItems> RepeaterItem 



30. When does a component render

a. When components are created
	-> when you just come to the page
	-> when you refresh the page
	-> when you navigate away from the component/page and come back to the page that contains the that component/page 

b. When components events are triggered
	-> even if we comment : currentCount++ , the component is still triggered
	-> as long as an event is triggered, the component will rerender
	-> component rerender only for UI events: click button, changing a dropdownlist, ...
	-> if we create an event or a delegate in c# and we want to trigger that event/delegate manually, 
	it will not work, the component will not render
	-> when a component UI are triggered, the components are rendered, but that UI event must be 
	inside the component
	-> if the event is outside of the component will not be rendered
ex1: if we have a button in the parent/child component, the child/parent component will not be rendered

Solution/Exception: use RenderFragment to pass the event from the child to the parent, so the component rerender
					
c. When components parameter values are changed 
use [Parameter] to pass the event to the child, so the component rerender

d. When developers manually trigger the rendering
UI:
<ChildComponent @ref="child" />

@code:
private ChildComponent child;

child.Counter = currentCount;
child.Refresh();

Rerender the child component:
public void Refresh()
{
    this.StateHasChanged();
}

Demo : Create a WebAssembly project

Debugging:
a. In Visual Studio
-- launchSettings.json --
"inspectUri": "{wsProtocol}://{url.hostname}:{url.port}/_framework/debug/ws-proxy?browser={browserInspectUri}",

b. In Browser
https://www.youtube.com/watch?v=QgRwaw_RQ8w&ab_channel=ZiaA.Shaikh

For more information:
https://docs.microsoft.com/en-us/aspnet/core/blazor/debug?view=aspnetcore-5.0&tabs=visual-studio


31. Component Lifecycle Events

I. First time Rendering
-> when the page is just loaded
-> when you navigate to the component

Methods: SetParameterAsync(), Oninitialized(), OnParameterSet()

Server Side Blazor:
Why they are rendered twice?

Browser -> Request -> Server
Browser <- Render 1 <- Server

Browser -> Signal R -> Server
Browser <- Render 2 <- Server

Blazor WebAssambly:
Browser -> Request -> Server
Browser <- Render 1 <- Server

Methods:  OnAfterRender()

-> after all of this the page is LOADED
-> the double loading happens when the app is loaded for the very first time !!


II. Rerendering
(8:30)
-> add a button to base and  child component

a. adding a parameter for the child component

How the methods are called: 
Parent - ShouldRender
	Child - SetParameters
	Child - OnPArametersSet
	Child - ShouldRender
Parent - OnAfterRender
	Child - OnAfterRender


b. without adding paramenter for the child component

How the methods are called: 
Parent - ShouldRender
Parent - OnAfterRender

-> the child component is not rendered ! 


32. Forms and Validations

-> blazor is a single pg app: only the first pageload goes to the HttpRequest and response pipeline
-> the subsequent actions will not be postback to the backend in order to perform submissions

Resolution:
<EditForm>,<InputText>,<InputNumber>

-> <EditForm> must be bind to a Model

@bind-Value: use inside the <EditForm>
@bind-value: use ouside the <EditForm>

UI:
-> create a EditForm with fields from class Person

@code:
-> Create class Person and put validations
-> create an obj of type Person: FirstName, LastName, EmployerNumber, Email
-> create a submit method for the OnValidSubmit: ValidFormSubmitted()


33. State Management with Observer Pattern

Recap:
-> Encapsulation: {get; set;}
-> Delegates : https://www.youtube.com/watch?v=R8Blt5c-Vi4&ab_channel=IAmTimCorey

Action delegate : https://www.tutorialsteacher.com/csharp/csharp-action-delegate
Func delegate	: https://www.tutorialsteacher.com/csharp/csharp-func-delegate


Action<T> Delegate:
	-> Encapsulates a method that has a single parameter and does not return a value.

Func<T,TResult> Delegate
	-> Encapsulates a method that has one parameter and returns a value of the type specified by the TResult parameter.

-- Action: 

static void ConsolePrint(int i)
{
    Console.WriteLine(i);
}

static void Main(string[] args)
{
    Action<int> printActionDel = ConsolePrint;
    printActionDel(10);
}

-- Func: 
static int Sum(int x, int y)
{
    return x + y;
}

static void Main(string[] args)
{
    Func<int,int, int> add = Sum;

    int result = add(10, 10);

    Console.WriteLine(result); 
}


-> STATE is at the component level or can be passed between components
-> but when you start writing more complex code, have complex projects, you need to save State outside of the component 
so every component in the page related to one another or NOT can access that STATE


IDisposable	: Provides a mechanism for releasing unmanaged resources.
Dispose()	: Performs application-defined tasks associated with freeing, releasing, or resetting unmanaged resources.


a. When access the Page
- NavMenu
	- OnInitialized
- CounterStore
	- AddStateChangeListeners
- NavMenu
	StateHasChanged(): Notifies the component that its state has changed. When applicable, this will
						 cause the component to be re-rendered.



-> we need to put breakpoint at every method to see the steps
b. When we press counter button:

- CounterStateManager
	- IncremetCounter()
- CounterStore
	- BroadcastStateChange()
- NavMenu
- CounterStore
	- GetState()
- CounterState



-- CounterStateManager.razor --
UI:
<button @onclick = "IncrementCounter">
<p>@counterStore.GetState().Count</p>

@code:
OnInitialized()
IncrementCounter()
UpdateView()
Dispose()


-- CounterStore.cs --

CounterState.cs
Count { get; }
ctor(int count)

CounterStore.cs
